# AGTMUX 実現可能性・リスクレビュー報告書

**レビュー対象**: agtmux-spec.md, implementation-plan.md, tasks.md, test-catalog.md
**レビュー日**: 2026-02-13
**レビュアー**: Opus Agent #3 (実現可能性・リスク)
**プロジェクト状態**: 実装コード未着手（ドキュメントのみ）

---

## 総合所見

本プロジェクトの仕様ドキュメント群は、内部整合性・トレーサビリティの観点では非常に高品質である。FR/NFR からタスク、テストケース、フェーズゲートまでの追跡可能性が確保されており、ドキュメント間の参照整合も取れている。

しかし、最大の懸念は **「設計の成熟度」と「実装準備度」のギャップ** である。仕様は分散システム級の堅牢性（冪等性、スナップショット検証、イベントソーシング的なストリーミング）を要求しているが、対象はシングルユーザーの開発者用CLIツールであり、設計の複雑さとユースケースの単純さに大きな乖離がある。

---

## 1. 技術的実現可能性

### [Critical] F-01: Claude CLI のフック機構への依存が未検証

仕様書 Section 7.4.1 で Claude アダプターは「hooks for lifecycle and interaction-needed signals」を利用すると記載されているが、Claude CLI が外部からフック可能な安定APIやイベントストリームを公開しているかどうかが明記されていない。Claude CLI はAnthropicの製品であり、そのフック機構は公式にドキュメント化されていない可能性がある。もしフックが存在しない、または内部仕様が頻繁に変わる場合、アダプターの中核が成立しなくなる。

**推奨:** Claude CLI のフック機構の実在性、安定性、バージョン互換保証について事前に技術検証（PoC）を実施し、フォールバック戦略（ポーリング+出力パーサー）を Phase 0 段階で確立すべき。

### [Critical] F-02: Codex CLI の notify イベント機構への依存が未検証

同様に Codex アダプターは `notify` イベント（`approval-requested`, `agent-turn-complete`）に依存するが、Codex CLI がこれらのイベントをどのようなインターフェースで外部に公開しているかの具体的な記述がない。ラッパーの `wrapper lifecycle signals` についても、どのようにプロセス起動を検知・制御するかの詳細設計が欠けている。

**推奨:** Claude と同様に PoC 実施が必須。各CLI のバージョンごとのイベント形式の差異を調査し、アダプター契約 (`ContractVersion`) の現実的なバージョニング戦略を策定すべき。

### [Major] F-03: tmux `server_boot_id` の取得方法が不明確

`pane_instance = (target_id, tmux_server_boot_id, pane_id)` というランタイムIDの導出に `tmux_server_boot_id` が不可欠だが、tmux がこの値を直接公開しているかは tmux のバージョンに依存する。tmux 3.3a 以降では `server_pid` や `start_time` で代替可能な場合があるが、`boot_id` という概念は tmux のネイティブ機能ではない。

**推奨:** tmux のどのバージョン・フォーマット変数を使って `server_boot_id` 相当の値を取得するか、具体的な実装方法を spec に明記すべき。tmux の最小サポートバージョンも定義が必要。

### [Major] F-04: SSH 経由のリモート tmux 操作のレイテンシとエラー特性

NFR-1 で「p95 <= 2秒」の可視遅延を要求しているが、SSH 経由のリモートターゲットで tmux コマンドを毎2秒ポーリングする場合、ネットワーク遅延・SSH接続のオーバーヘッドが累積する。特にベンチマークプロファイル（3ターゲット、60ペイン、10イベント/秒）は SSH 経由で現実的にこの SLO を達成できるか疑問がある。

**推奨:** SSH 接続のマルチプレクシング（ControlMaster）の利用を前提とするか、リモートターゲット上にコレクタープロセスを常駐させる設計を検討すべき。ベンチマークプロファイルにネットワーク条件（RTT想定値等）を追加すべき。

### [Minor] F-05: `tmux capture-pane` の出力パーシング信頼性

Gemini アダプターおよび将来の Copilot/Cursor アダプターは「wrapper + parser approach」に依存する。ターミナル出力のパーシングは、ANSIエスケープシーケンス、行折返し、ターミナルサイズ変更などの影響を受けやすい。仕様書のリスクセクション（Section 9）でも「parser fragility」として認識されているが、具体的な対策（例：ANSIストリップ処理、パーサーバージョニング）が不足している。

**推奨:** パーサーの堅牢性要件を NFR に追加し、ANSIエスケープ処理の標準的なライブラリ採用を明記すべき。

---

## 2. 実装の複雑さ

### [Critical] C-01: Phase 0 のスコープが MVP として過大

Phase 0 だけで以下を要求している:
- SQLiteスキーマ全体（12テーブル、複雑なインデックス群）
- ランタイムIDライフサイクル（`sha256` 導出、`pane_epoch`管理）
- イベント ordering/dedupe アルゴリズム（`source_seq`, `effective_event_time`, `skew_budget`）
- `event_inbox` バインドリゾルバー
- リコンサイラー
- TargetExecutor + デーモン境界
- tmux トポロジオブザーバー
- ペイロードレダクション + リテンションジョブ
- 17テストケースのゲート

これは「Core Runtime」と称しているが、実質的には完全なバックエンドエンジンの構築に等しい。Phase 0 のゲート通過に必要なテストケース数（TC-001 から TC-013, TC-040, TC-041, TC-049, TC-050）は17個あり、初期フェーズとしては非常に重い。

**推奨:** Phase 0 をさらに 0a（スキーマ + 基本CRUD）と 0b（ordering/dedupe + reconciler + inbox resolver）に分割し、早期にフィードバックループを回せるようにすべき。

### [Major] C-02: Action Snapshot メカニズムの過剰設計の懸念

制御アクション（attach, send, kill, view-output）に対して、サーバーサイドのスナップショット検証、有効期限付きnonce、冪等性キー（`request_ref`）、`state_version` 比較、ガードフラグ(`--if-runtime`, `--if-state`, `--if-updated-within`) という多重の安全機構が組み込まれている。CLI ツールとしてこのレベルの安全機構が本当に必要かは疑問がある。

ユースケースの主体は「開発者が自分の tmux ペインを操作する」というシングルユーザーシナリオであり、分散トランザクションのような厳密な一貫性は過剰である可能性がある。特に `action_snapshots` テーブル、`expires_at`、`nonce` は、将来の macOS アプリとの並行操作を見据えたものと思われるが、YAGNI 原則に反する。

**推奨:** MVP（Phase 1/1.5）では `runtime_id` 検証 + 基本的な freshness チェック程度に簡素化し、Action Snapshot の完全実装は macOS アプリ統合時（Phase 3）に延期すべき。

### [Major] C-03: Watch ストリームの実装複雑度

Watch 機能の要件が非常に重い:
- `stream_id` + `sequence` による monotonic cursor
- `snapshot/delta/reset` の3つのイベントタイプ
- cursor の有効期限管理と `E_CURSOR_EXPIRED` のハンドリング
- daemon リスタート後の継続性（TC-051）

これは実質的にイベントソーシングシステムの構築に等しく、CLIモニタリングツールとしては過剰な複雑性を持つ。

**推奨:** MVP では `watch --once`（ワンショットスナップショット）と単純なポーリングベースの `watch`（定期リフレッシュ）で十分。delta/cursor ベースのストリーミングは Phase 2 以降に延期すべき。

### [Minor] C-04: Canonical Action Reference Grammar の解析複雑度

BNF 文法で定義されたリファレンス形式（`runtime:<runtime-id>` / `pane:<target>/<session-enc>/<window-id>/<pane-id>`）は、パーセントエンコーディング、immutable ID の使用制約など、ユーザーが手入力するには煩雑すぎる。

**推奨:** ユーザーフレンドリーな短縮形式（ファジーマッチ、タブ補完）を優先し、完全修飾形式はプログラマティックアクセス用として位置付けるべき。

---

## 3. 外部依存リスク

### [Critical] D-01: エージェント CLI のバージョン互換性リスク

Claude CLI, Codex CLI, Gemini CLI はすべて活発に開発中の製品であり、イベント形式やフック機構が予告なく変更される可能性が極めて高い。仕様書の `ContractVersion()` でアダプターのバージョニングは定義されているが、上流 CLI の破壊的変更にどう対応するかのプランがない。

**推奨:**
- 各 CLI の最小/最大サポートバージョンを明示
- CLI のバージョン検出機構をアダプター契約に追加
- CLI 側の破壊的変更に対する degradation 戦略（unknown 状態へのフォールバック）を明文化

### [Major] D-02: 技術スタック未選定

仕様書は「SQLite recommended」とし、API は REST 的なエンドポイントを定義しているが、実装言語、フレームワーク、ランタイムが一切決定されていない。`package.json` や `Cargo.toml` 等の設定ファイルも存在しない。これにより:
- 依存パッケージのリスク評価が不可能
- ビルド・テスト・配布のパイプライン設計が未着手
- 技術選定によっては仕様の実現難易度が大きく変わる（例：Node.js vs Go vs Rust での SQLite バインディング品質の差異）

**推奨:** Phase 0 開始前に技術スタックを確定し、プロトタイプでの検証を行うべき。

### [Major] D-03: tmux バージョン互換性

仕様は tmux の多数の機能（`capture-pane`, `send-keys`, `list-panes` のフォーマット文字列、`pane_id` の immutable ID 形式等）に依存しているが、サポートする tmux のバージョン範囲が定義されていない。macOS 標準の tmux（Homebrew版）と Linux ディストリビューション同梱版でバージョンが異なるケースが多い。

**推奨:** tmux 3.x 以上（具体的なバージョン）を最小要件として定義し、インストール時のバージョンチェック機構を実装すべき。

### [Minor] D-04: SQLite の同時アクセス制約

SQLite は WAL モードでも同時書き込みはシリアライズされる。デーモン (`agtmuxd`) が複数のコレクターからのイベントを同時受信する場合、SQLite のロック競合が性能ボトルネックになりうる。TC-052 で「SQLite busy/lock recovery」はテスト対象になっているが、設計レベルでの対策（バッファリング、バッチ書き込み等）が未記載。

**推奨:** イベントインジェストのバッチ化戦略を設計に追加すべき。

---

## 4. エラーハンドリング

### [Major] E-01: デーモンプロセスのクラッシュ回復戦略が未定義

`agtmuxd` がクラッシュした場合の回復手順が定義されていない:
- SQLite に未コミットのトランザクションがある場合のデータ整合性
- Watch ストリームの接続中クライアントへの通知
- リコンサイラーの再初期化手順
- PID ファイル管理やプロセス監視の方法

TC-051 で「daemon restart 後の watch continuity」はテストされるが、それ以外のクラッシュリカバリシナリオが不足。

**推奨:** daemon の起動・停止・クラッシュ回復のライフサイクルを仕様に追加。systemd / launchd でのプロセス管理を想定した設計を明記すべき。

### [Major] E-02: SSH 接続の断続的障害への対策不足

SSH ターゲットへの接続が一時的に不安定になるケース（ネットワーク断、SSH接続タイムアウト、認証切れ）の詳細な挙動が未定義。仕様書では「target health: `ok`/`degraded`/`down`」の3状態を定義しているが:
- `degraded` と `down` の判定基準（何回連続失敗で遷移するか）
- `down` から `ok` への復帰条件
- 接続プールの管理とタイムアウト設定

**推奨:** ターゲット健全性の状態遷移図と、各遷移の具体的な判定条件を仕様に追加すべき。

### [Major] E-03: リソース枯渇シナリオの考慮不足

以下のリソース枯渇シナリオへの対策が不足:
- SQLite ファイルの肥大化（リテンションジョブはあるが、急激なイベントバーストへの対策がない）
- `event_inbox` の `pending_bind` エントリの蓄積
- Watch ストリームのメモリ使用量（多数のクライアントが同時接続した場合）
- tmux セッション/ペインが大量（数百以上）存在する場合のスキャン負荷

**推奨:** 各リソースの上限値と、上限到達時のバックプレッシャー戦略を定義すべき。

### [Minor] E-04: クロック同期の前提が明記されていない

`skew_budget` で10秒のクロック差を許容しているが、ホストとVM間のクロック同期が保証されていない環境（NTP未設定のVM等）では10秒では不十分な場合がある。

**推奨:** クロック同期の前提条件（NTP推奨等）を NFR または運用要件に追加すべき。

---

## 5. プロジェクトリスク

### [Critical] P-01: MVP の定義が不明確 -- 最初のユーザー価値提供が Phase 1 完了後

Phase 0 は純粋にインフラ構築であり、ユーザーに直接の価値を提供しない。Phase 1 完了までに以下が必要:
- Phase 0 全タスク（TASK-001 ~ TASK-008, TASK-031, TASK-032, TASK-038）: 11タスク
- Phase 1 全タスク（TASK-009 ~ TASK-018, TASK-033, TASK-034）: 12タスク
- 合計23タスク、33テストケース

実装コードゼロの状態からこれだけの規模を完了して初めて「手動ポーリングが不要になる」という最初のユーザー価値が得られる。プロジェクトの中断リスクを考慮すると、もっと早い段階でユーザー価値を確認できる設計が望ましい。

**推奨:** 「Phase 0.5: 単一ターゲット（local）で tmux ペイン一覧 + Claude の状態表示（ポーリングベース）」のような、2-3日で動作確認可能なスケルトン MVP を最初に定義すべき。SQLite スキーマや ordering/dedupe は段階的に洗練させれば良い。

### [Major] P-02: フェーズ数の多さと各フェーズの粒度不均一

Phase 0 / 1 / 1.5 / 2 / 2.5 / 3 の6フェーズは、各フェーズのサイズが大きく異なる:
- Phase 0: 11タスク、17テスト
- Phase 1: 12タスク、16テスト追加
- Phase 1.5: 5タスク、9テスト追加
- Phase 2: 4タスク、6テスト追加
- Phase 2.5: 2タスク、3テスト追加
- Phase 3: 2タスク、2テスト追加

Phase 0 と Phase 1 が巨大で、後半は小さい。初期フェーズの負荷が集中しすぎている。

**推奨:** Phase 0 + 1 を計4-5個の小さなマイルストーンに再分割し、各2週間程度で完了可能な粒度にすべき。

### [Major] P-03: 開発リソースの前提が不明

タスクの工数見積もりが一切存在しない。開発者数、利用可能な時間、目標スケジュールが定義されていない。引継ぎドキュメント (`tmp/handover-orchestrator-2026-02-13-detailed.md`) では並列レーン（Lane A-E）を提案しているが、これは少なくとも3-5人の開発者を前提としているように見える。

**推奨:** 開発リソースの現実的な前提を明記し、それに基づいたタイムラインを策定すべき。

### [Minor] P-04: macOS アプリ (Phase 3) の ROI が不明

Phase 3 の macOS レジデントアプリは、CLI で同等の機能が提供される中で、追加開発コストに見合うユーザー価値があるか疑問。SwiftUI/AppKit の開発スキルが必要であり、メンテナンスコストも増大する。

**推奨:** Phase 3 は「検討中」ステータスに留め、Phase 2 完了後の利用状況を見て判断すべき。

---

## 6. 運用リスク

### [Critical] O-01: CI/CD パイプラインが未設計

テストカタログは53のテストケースを定義し、CI / Nightly / Manual+CI の3層を想定しているが:
- CI 実行環境の定義がない（GitHub Actions? ローカル?）
- Nightly テストの実行インフラが未構築
- テストフレームワークすら未選定（技術スタック未確定のため）
- tmux を必要とする E2E テストの CI 上での実行方法が未定義

特に tmux が必要なテストを CI 上で実行するには、仮想ターミナル環境の構築が必要であり、これ自体が非自明な課題。

**推奨:** Phase 0 のタスクリストに「CI パイプライン構築」を P0 タスクとして追加すべき。tmux テスト用の Docker イメージまたは CI ジョブの設計を事前に行うべき。

### [Major] O-02: デーモン (`agtmuxd`) のデプロイ・管理方法が未定義

`agtmuxd` はバックグラウンドデーモンとして動作する想定だが:
- インストール方法（npm global? brew? バイナリ配布?）
- 起動方法（手動? launchd/systemd? ログインシェル?）
- アップデート戦略（ローリングアップデート? スキーママイグレーション?）
- ログの出力先と管理
- 設定ファイルの形式と場所

**推奨:** デーモンのライフサイクル管理を仕様書に追加すべき。最低限、起動・停止コマンド（`agtmux daemon start/stop/status`）を CLI に追加し、ログローテーション戦略を定義すべき。

### [Major] O-03: デバッグ・トラブルシューティングの手段が不足

問題発生時のデバッグ手段が定義されていない:
- ログレベルの設定（debug/info/warn/error）
- 内部状態のダンプコマンド
- イベント再生（replay）機能
- SQLite DB の直接検査手順

**推奨:** `agtmux debug` サブコマンド群（例：`agtmux debug dump-state`, `agtmux debug replay-events`）を Phase 1 のスコープに追加すべき。

### [Minor] O-04: 設定の一元管理方法が未定義

設定可能なパラメータが仕様中に散在している:
- `completed -> idle` のデモーション時間（120秒）
- リコンサイラーのスキャン間隔（2秒）
- `skew_budget`（10秒）
- イベント保持期間（7日/14日）
- `pending_bind` TTL

これらの設定値をどこで管理し（設定ファイル? 環境変数? CLI フラグ?）、実行時に変更可能かどうかが未定義。

**推奨:** 設定管理の方針（ファイル形式、デフォルト値、オーバーライド方法）を仕様に追加すべき。

---

## 指摘事項サマリー

| 重要度 | ID | カテゴリ | 概要 |
|---|---|---|---|
| Critical | F-01 | 技術的実現可能性 | Claude CLI フック機構の実在性・安定性が未検証 |
| Critical | F-02 | 技術的実現可能性 | Codex CLI notify イベント機構の実在性・安定性が未検証 |
| Critical | C-01 | 実装の複雑さ | Phase 0 のスコープが MVP として過大 |
| Critical | D-01 | 外部依存リスク | エージェント CLI のバージョン互換性リスク |
| Critical | P-01 | プロジェクトリスク | 最初のユーザー価値提供が遅すぎる |
| Critical | O-01 | 運用リスク | CI/CD パイプラインが未設計 |
| Major | F-03 | 技術的実現可能性 | tmux `server_boot_id` の取得方法が不明確 |
| Major | F-04 | 技術的実現可能性 | SSH経由リモート操作のレイテンシ問題 |
| Major | C-02 | 実装の複雑さ | Action Snapshot メカニズムの過剰設計 |
| Major | C-03 | 実装の複雑さ | Watch ストリームの実装が過度に複雑 |
| Major | D-02 | 外部依存リスク | 技術スタック未選定 |
| Major | D-03 | 外部依存リスク | tmux バージョン互換性未定義 |
| Major | E-01 | エラーハンドリング | デーモンクラッシュ回復戦略が未定義 |
| Major | E-02 | エラーハンドリング | SSH接続障害への対策不足 |
| Major | E-03 | エラーハンドリング | リソース枯渇シナリオの考慮不足 |
| Major | P-02 | プロジェクトリスク | フェーズサイズの不均一 |
| Major | P-03 | プロジェクトリスク | 開発リソースの前提が不明 |
| Major | O-02 | 運用リスク | デーモンのデプロイ・管理方法が未定義 |
| Major | O-03 | 運用リスク | デバッグ・トラブルシューティング手段不足 |
| Minor | F-05 | 技術的実現可能性 | ターミナル出力パーシングの堅牢性 |
| Minor | C-04 | 実装の複雑さ | Action Reference Grammar のユーザビリティ |
| Minor | D-04 | 外部依存リスク | SQLite 同時アクセス制約 |
| Minor | E-04 | エラーハンドリング | クロック同期の前提が未記載 |
| Minor | P-04 | プロジェクトリスク | macOS アプリの ROI が不明 |
| Minor | O-04 | 運用リスク | 設定の一元管理方法が未定義 |

---

## 最優先で取り組むべき3点

1. **技術 PoC の実施**（F-01, F-02）: Claude CLI / Codex CLI のフック・イベント機構が実際に利用可能であることを、1-2日の PoC で確認すべき。これが成立しなければプロジェクト全体の前提が崩れる。

2. **スケルトン MVP の早期構築**（P-01, C-01）: 現在の Phase 0+1 の23タスクを待たずに、「単一ターゲット + Claude + ポーリングベースの状態表示」という最小動作版を2-3日で作り、ユーザー価値を早期に確認すべき。

3. **技術スタックの確定と CI 構築**（D-02, O-01）: 言語・フレームワーク選定とCI環境構築を Phase 0 の最初のタスクとすべき。これなしにはテストカタログの実装もできない。
